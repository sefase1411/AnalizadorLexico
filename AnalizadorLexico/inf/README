# Compilador GoxLang con M√°quina Virtual de Pila

Este proyecto implementa un **compilador completo** para el lenguaje de programaci√≥n **GoxLang** (combinaci√≥n entre GO y LOX), incluyendo una **m√°quina virtual basada en pila** para la ejecuci√≥n de c√≥digo intermedio (IR).

## üë• Equipo de Trabajo

- **Sebasti√°n Fajardo Serna**
- **Samuel Garc√≠a Cristancho**
- **Juan Camilo Rodr√≠guez**

## üéØ Objetivo del Proyecto

Desarrollar un compilador de m√∫ltiples fases que transforme c√≥digo fuente GoxLang en c√≥digo ejecutable mediante una m√°quina virtual de pila, demostrando los conceptos fundamentales de compiladores: an√°lisis l√©xico, sint√°ctico, sem√°ntico, generaci√≥n de c√≥digo intermedio y ejecuci√≥n.

## üèóÔ∏è Arquitectura del Compilador

El compilador sigue el pipeline tradicional de compilaci√≥n:

```
C√≥digo Fuente (.gox) ‚Üí An√°lisis L√©xico ‚Üí An√°lisis Sint√°ctico ‚Üí An√°lisis Sem√°ntico ‚Üí Generaci√≥n IR ‚Üí M√°quina de Pila ‚Üí Ejecuci√≥n
```

### Componentes Principales

| Componente                | Archivo            | Descripci√≥n                        |
| ------------------------- | ------------------ | ---------------------------------- |
| **Analizador L√©xico**     | `lexer.py`         | Tokenizaci√≥n del c√≥digo fuente     |
| **Analizador Sint√°ctico** | `parser.py`        | Construcci√≥n del AST               |
| **Analizador Sem√°ntico**  | `check.py`         | Verificaci√≥n de tipos y sem√°ntica  |
| **Generador de IR**       | `ircode.py`        | Generaci√≥n de c√≥digo intermedio    |
| **M√°quina de Pila**       | `stack_machine.py` | Ejecuci√≥n del c√≥digo IR            |
| **Modelo AST**            | `model.py`         | Definici√≥n de nodos del AST        |
| **Sistema de Tipos**      | `typesys.py`       | Definici√≥n y verificaci√≥n de tipos |
| **Tabla de S√≠mbolos**     | `symtab.py`        | Manejo de scopes y variables       |

## üöÄ Caracter√≠sticas Implementadas

### An√°lisis L√©xico

- ‚úÖ Reconocimiento de tokens (palabras clave, operadores, literales)
- ‚úÖ Manejo de comentarios de l√≠nea (`//`) y bloque (`/* */`)
- ‚úÖ Detecci√≥n de errores l√©xicos
- ‚úÖ Informaci√≥n de posici√≥n (l√≠nea/columna)
- ‚úÖ Soporte para literales de car√°cter y cadenas
- ‚úÖ Validaci√≥n de comentarios no cerrados

### An√°lisis Sint√°ctico

- ‚úÖ Parser recursivo descendente
- ‚úÖ Manejo de precedencia de operadores
- ‚úÖ Construcci√≥n de AST completo
- ‚úÖ Recuperaci√≥n de errores sint√°cticos

### An√°lisis Sem√°ntico

- ‚úÖ Verificaci√≥n de tipos
- ‚úÖ Tabla de s√≠mbolos con scopes anidados
- ‚úÖ Verificaci√≥n de declaraciones y uso de variables
- ‚úÖ Validaci√≥n de llamadas a funciones

### Generaci√≥n de C√≥digo Intermedio

- ‚úÖ IR basado en instrucciones de pila
- ‚úÖ Optimizaci√≥n de orden de instrucciones
- ‚úÖ Manejo de variables locales y globales
- ‚úÖ Soporte para funciones y control de flujo

### M√°quina Virtual de Pila

- ‚úÖ Ejecuci√≥n completa de instrucciones IR
- ‚úÖ Stack de activaci√≥n con CallFrames
- ‚úÖ Memoria lineal byte-addressable
- ‚úÖ Soporte para recursi√≥n
- ‚úÖ Manejo de par√°metros y valores de retorno

## üìã Implementaci√≥n del Analizador L√©xico

El analizador l√©xico utiliza expresiones regulares para reconocer los diferentes tokens del lenguaje:

### Tokens Principales

- **Palabras clave**: `var`, `const`, `if`, `else`, `while`, `func`, `int`, `bool`, `true`, `false`
- **Operadores aritm√©ticos**: `+`, `-`, `*`, `/`, `%`
- **Operadores l√≥gicos**: `&&`, `||`
- **Operadores de comparaci√≥n**: `==`, `!=`, `<=`, `>=`, `<`, `>`
- **Identificadores y literales**: n√∫meros, cadenas de texto, caracteres

### Proceso de Tokenizaci√≥n

1. **Definici√≥n de tokens** con sus respectivas expresiones regulares
2. **An√°lisis del c√≥digo fuente**, reconociendo los tokens v√°lidos
3. **Almacenamiento de tokens** junto con informaci√≥n de l√≠nea y valor
4. **Detecci√≥n y manejo de errores** l√©xicos como caracteres ilegales

### Manejo de Comentarios

```python
def t_COMMENT(t):
    r'//.*'
    pass  # Ignora comentarios de l√≠nea

def t_MULTILINE_COMMENT(t):
    r'/\*[\s\S]*?\*/'
    t.lexer.lineno += t.value.count('\n')
    pass  # Ignora comentarios multil√≠nea
```

## üìã Instrucciones IR Soportadas

### Aritm√©tica

- **Enteros**: `ADDI`, `SUBI`, `MULI`, `DIVI`
- **Flotantes**: `ADDF`, `SUBF`, `MULF`, `DIVF`

### Comparaciones

- **Enteros**: `EQI`, `NEI`, `LTI`, `LEI`, `GTI`, `GEI`
- **Flotantes**: `EQF`, `NEF`

### L√≥gica

- `ANDI`, `ORI`

### Conversiones

- `ITOF`, `FTOI`

### Variables

- `LOCAL_GET`, `LOCAL_SET`, `GLOBAL_GET`, `GLOBAL_SET`

### Control de Flujo

- `IF`, `ELSE`, `ENDIF`, `LOOP`, `CBREAK`, `ENDLOOP`

### Funciones

- `CALL`, `RET`

### Memoria

- `PEEKI`, `POKEI`, `PEEKF`, `POKEF`, `PEEKB`, `POKEB`, `GROW`

### E/S

- `PRINTI`, `PRINTF`, `PRINTB`

## üîß Problemas Encontrados y Soluciones

### An√°lisis L√©xico

#### 1. Comentarios No Terminados

**Problema**: El lexer no detectaba correctamente los comentarios de m√∫ltiples l√≠neas no cerrados (`/* ...`).

**Soluci√≥n**: Se modific√≥ la l√≥gica de detecci√≥n de comentarios para verificar si un `/*` tiene su correspondiente `*/`. Si no lo tiene, se lanza una `SyntaxError` indicando la l√≠nea del error.

```python
def check_unterminated_comment(source_code):
    open_comment = source_code.find("/*")
    close_comment = source_code.find("*/", open_comment + 2)
    if open_comment != -1 and close_comment == -1:
        line_number = source_code[:open_comment].count("\n") + 1
        raise SyntaxError(f"L√≠nea {line_number}: Comentario no terminado")
```

#### 2. Errores con Caracteres Ilegales

**Problema**: El lexer no identificaba algunos caracteres inv√°lidos y segu√≠a ejecut√°ndose sin lanzar errores.

**Soluci√≥n**: Se agreg√≥ una validaci√≥n que, si ning√∫n token coincide en una posici√≥n dada del c√≥digo, se lanza un `SyntaxError` indicando la l√≠nea y el car√°cter problem√°tico.

```python
def t_error(t):
    print(f"[Lexer] Caracter ilegal '{t.value[0]}' en l√≠nea {t.lexer.lineno}")
    t.lexer.skip(1)
```

#### 3. Pruebas Fallidas en pytest

**Problema**: La prueba `test_unterminated_comment` fallaba porque el lexer no generaba la excepci√≥n esperada.

**Soluci√≥n**: Se corrigi√≥ la detecci√≥n de comentarios no cerrados, asegur√°ndose de que pytest pudiera detectar correctamente el `SyntaxError`.

### Fase M√°quina Virtual de Pila

#### 1. Orden Incorrecto de Instrucciones IR

**Problema**: Las variables globales se le√≠an antes de ser inicializadas.

```ir
('GLOBAL_GET', 'x')    # ‚Üê Lee x (valor 0)
('PRINTI',)            # ‚Üê Imprime 0
('CONSTI', 42)         # ‚Üê Despu√©s asigna 42
('GLOBAL_SET', 'x')
```

**Soluci√≥n**: Reorganizamos el generador de IR para ejecutar inicializaciones antes que los statements.

```ir
('CONSTI', 42)         # ‚Üê Primero asigna 42
('GLOBAL_SET', 'x')
('GLOBAL_GET', 'x')    # ‚Üê Luego lee x (valor 42)
('PRINTI',)            # ‚Üê Imprime 42
```

#### 2. Llamadas a Funciones sin Par√°metros

**Problema**: Las funciones no recib√≠an par√°metros correctamente, siempre retornaban 0.

**Soluci√≥n**: Implementamos manejo completo de par√°metros en `_exec_call`:

- Extracci√≥n de par√°metros del stack
- Asignaci√≥n a variables locales del CallFrame
- Preservaci√≥n del valor de retorno

```python
def _exec_call(self, func_name):
    # Extraer par√°metros del stack
    param_count = self._get_param_count(func_name)
    params = []
    for _ in range(param_count):
        if self.stack:
            params.append(self.stack.pop())

    # Crear CallFrame y asignar par√°metros
    new_frame = CallFrame(func_name, return_address, param_count)
    param_names = self._get_param_names(func_name)
    for i, param_name in enumerate(param_names):
        if i < len(params):
            new_frame.set_local(param_name, params[i])
```

#### 3. Gesti√≥n de Stack de Activaci√≥n

**Problema**: Los valores de retorno se perd√≠an entre llamadas a funciones.

**Soluci√≥n**: Corregimos `_exec_ret` para mantener el valor de retorno en el stack principal.

#### 4. Divisi√≥n por Cero en Algoritmo Shor

**Problema**: El algoritmo de Shor causaba divisi√≥n por cero en casos espec√≠ficos.

**Soluci√≥n**: Agregamos validaci√≥n en la funci√≥n `mod` para manejar casos edge.

```gox
func mod(a int, b int) int {
    if (b == 0) {
        return 0;
    }
    return a - b * (a / b);
}
```

## üß™ Suite de Pruebas

### Pruebas del Analizador L√©xico

```python
def test_token_var_decl(self):
    code = "var x int = 10;"
    tokens = tokenize(code)
    expected = [
        ('VAR', 'var', 1),
        ('ID', 'x', 1),
        ('INT', 'int', 1),
        ('ASSIGN', '=', 1),
        ('NUMBER', 10, 1),
        (';', ';', 1),
        ('EOF', '', 1)
    ]
    self.assertEqual(tokens, expected)
```

### Pruebas de la M√°quina de Pila

1. **Aritm√©tica B√°sica**: Operaciones `+`, `-`, `*`, `/`
2. **Llamadas a Funciones**: Paso de par√°metros y valores de retorno
3. **Condicionales**: Estructuras `if/else`
4. **Bucles**: Estructuras `while`
5. **Recursi√≥n**: Funciones recursivas (factorial)
6. **Variables Globales**: Declaraci√≥n e inicializaci√≥n
7. **Variables Locales**: Scope y persistencia
8. **Programa Complejo**: Algoritmo de Shor para factorizaci√≥n

### Resultados de Pruebas

```
RESULTADOS: 7/8 pruebas pasaron
- arithmetic: ‚úÖ PASSED
- functions: ‚úÖ PASSED
- conditionals: ‚úÖ PASSED
- loops: ‚úÖ PASSED
- recursion: ‚úÖ PASSED
- global_vars: ‚úÖ PASSED
- local_vars: ‚úÖ PASSED
- complex_shor: ‚è±Ô∏è TIMEOUT (comportamiento esperado para n√∫meros grandes)
```

## üìÇ Estructura del Proyecto

```
GoxLang-Compiler/
‚îú‚îÄ‚îÄ üìÅ Compilador Principal
‚îÇ   ‚îú‚îÄ‚îÄ lexer.py              # An√°lisis l√©xico
‚îÇ   ‚îú‚îÄ‚îÄ parser.py             # An√°lisis sint√°ctico
‚îÇ   ‚îú‚îÄ‚îÄ check.py              # An√°lisis sem√°ntico
‚îÇ   ‚îú‚îÄ‚îÄ ircode.py             # Generaci√≥n de IR
‚îÇ   ‚îú‚îÄ‚îÄ stack_machine.py      # M√°quina virtual de pila
‚îÇ   ‚îî‚îÄ‚îÄ main.py               # Pipeline principal
‚îú‚îÄ‚îÄ üìÅ Infraestructura
‚îÇ   ‚îú‚îÄ‚îÄ model.py              # Definici√≥n del AST
‚îÇ   ‚îú‚îÄ‚îÄ typesys.py            # Sistema de tipos
‚îÇ   ‚îú‚îÄ‚îÄ symtab.py             # Tabla de s√≠mbolos
‚îÇ   ‚îî‚îÄ‚îÄ diagnostics.py        # Manejo de errores
‚îú‚îÄ‚îÄ üìÅ Utilidades
‚îÇ   ‚îú‚îÄ‚îÄ ast_utility.py        # Exportaci√≥n de AST
‚îÇ   ‚îî‚îÄ‚îÄ symtab_utility.py     # Exportaci√≥n de s√≠mbolos
‚îú‚îÄ‚îÄ üìÅ Pruebas
‚îÇ   ‚îú‚îÄ‚îÄ test_stack_machine.py # Suite de pruebas de la VM
‚îÇ   ‚îî‚îÄ‚îÄ pruebasunitarias.py   # Pruebas del lexer/parser
‚îú‚îÄ‚îÄ üìÅ Ejemplos
‚îÇ   ‚îú‚îÄ‚îÄ shor.gox              # Algoritmo de Shor
‚îÇ   ‚îî‚îÄ‚îÄ factorize.gox         # Factorizaci√≥n
‚îú‚îÄ‚îÄ üìÅ Extensi√≥n VS Code
‚îÇ   ‚îú‚îÄ‚îÄ extension.js          # L√≥gica de la extensi√≥n
‚îÇ   ‚îú‚îÄ‚îÄ package.json          # Configuraci√≥n
‚îÇ   ‚îî‚îÄ‚îÄ gox.tmLanguage.json   # Syntax highlighting
‚îî‚îÄ‚îÄ üìÅ Documentaci√≥n
    ‚îî‚îÄ‚îÄ README.md             # Este archivo
```

## üöÄ Instalaci√≥n y Uso

### Prerrequisitos

```bash
Python 3.8+
pip install ply rich
```

### Uso del Analizador L√©xico

```bash
python lexer.py
```

### Uso del Compilador Completo

```bash
# Compilar un programa
python main.py programa.gox

# Compilar y ejecutar
python main.py programa.gox --execute

# Compilar con debug
python main.py programa.gox --vm-debug

# Ejecutar pruebas del lexer
pytest pruebasunitarias.py

# Ejecutar pruebas de la m√°quina de pila
python test_stack_machine.py
```

### Ejemplo de Programa GoxLang

```gox
func factorial(n int) int {
    if (n <= 1) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}

var result int = factorial(5);
print result;  // Imprime: 120
```

## üìö Referencias Acad√©micas

- **Dragon Book**: Compilers: Principles, Techniques, and Tools
- **Modern Compiler Implementation**: Andrew W. Appel
- **Engineering a Compiler**: Keith Cooper & Linda Torczon
- **Crafting Interpreters**: Robert Nystrom

---

**Este proyecto demuestra una implementaci√≥n completa y funcional de un compilador moderno con m√°quina virtual, aplicando los principios fundamentales de la teor√≠a de compiladores desde el an√°lisis l√©xico hasta la ejecuci√≥n, con manejo robusto de errores y una suite de pruebas exhaustiva.**
